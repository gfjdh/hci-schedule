import React, { useEffect, useState } from 'react';
import EventTile from './EventTile';
import { CustomButton } from './Buttons';
import { type Event, EventManager, initialEvents } from './EventManager';
import './ScheduleArea.css';

const ScheduleArea: React.FC = () => {
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [tempEvent, setTempEvent] = useState<Partial<Event> | null>(null);
  const [eventManager] = useState<EventManager>(() => new EventManager(initialEvents));
  const [events, setEvents] = useState<Event[]>([]);
  
  // ËØ≠Èü≥ËØÜÂà´Áõ∏ÂÖ≥Áä∂ÊÄÅ
  const [isListening, setIsListening] = useState(false);
  const [speechRecognition, setSpeechRecognition] = useState<SpeechRecognition | null>(null);
  const [commandInput, setCommandInput] = useState('');
  const [speechSupported, setSpeechSupported] = useState(false);
  const [speechError, setSpeechError] = useState<string>('');
  const [lastRecognizedText, setLastRecognizedText] = useState<string>('');
  const [debugInfo, setDebugInfo] = useState<string[]>([]);
  const [debugPanelVisible, setDebugPanelVisible] = useState(false);
  const [debugPanelPosition, setDebugPanelPosition] = useState({ x: 10, y: 60 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [microphonePermission, setMicrophonePermission] = useState<string>('unknown');
  const [audioLevel, setAudioLevel] = useState<number>(0);
  const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);
  
  // ÁéØÂ¢ÉÊ£ÄÊµã
  const isDevelopment = import.meta.env.VITE_APP_ENV === 'development' || import.meta.env.DEV;
  
  // Ê∑ªÂä†Ë∞ÉËØïÊó•ÂøóÂáΩÊï∞
  const addDebugLog = (message: string) => {
    if (isDevelopment) {
      const timestamp = new Date().toLocaleTimeString();
      const logMessage = `[${timestamp}] ${message}`;
      setDebugInfo(prev => [...prev.slice(-4), logMessage]); // ‰øùÁïôÊúÄËøë5Êù°Êó•Âøó
      console.log('üé§ ËØ≠Èü≥Ë∞ÉËØï:', logMessage);
    }
  };

  // ÂΩì‰∫ã‰ª∂ÁÆ°ÁêÜÂô®‰∏≠ÁöÑÊï∞ÊçÆÂèòÂåñÊó∂Êõ¥Êñ∞Áä∂ÊÄÅ
  useEffect(() => {
    setEvents(eventManager.getAllEvents());
  }, [eventManager]);

  // Ê∏ÖÁêÜÂ™í‰ΩìÊµÅ
  useEffect(() => {
    return () => {
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        addDebugLog('Â™í‰ΩìÊµÅÂ∑≤Ê∏ÖÁêÜ');
      }
    };
  }, [mediaStream]);

  // Ê£ÄÊµãÈ∫¶ÂÖãÈ£éÊùÉÈôêÂíåÈü≥È¢ëËæìÂÖ•
  const checkMicrophoneAccess = async () => {
    try {
      addDebugLog('Ê£ÄÊµãÈ∫¶ÂÖãÈ£éÊùÉÈôê...');
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      setMicrophonePermission('granted');
      setMediaStream(stream);
      addDebugLog('È∫¶ÂÖãÈ£éÊùÉÈôêÂ∑≤Ëé∑ÂèñÔºåÂºÄÂßãÁõëÊéßÈü≥È¢ëÁ∫ßÂà´');
      
      // ÂàõÂª∫Èü≥È¢ëÂàÜÊûêÂô®Êù•ÁõëÊéßÈü≥È¢ëÁ∫ßÂà´
      const audioContext = new AudioContext();
      const analyser = audioContext.createAnalyser();
      const microphone = audioContext.createMediaStreamSource(stream);
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      
      microphone.connect(analyser);
      analyser.fftSize = 256;
      
      const updateAudioLevel = () => {
        analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        setAudioLevel(Math.round(average));
        
        if (mediaStream && mediaStream.active) {
          requestAnimationFrame(updateAudioLevel);
        }
      };
      
      updateAudioLevel();
    } catch (error) {
      setMicrophonePermission('denied');
      addDebugLog(`È∫¶ÂÖãÈ£éÊùÉÈôêÊ£ÄÊµãÂ§±Ë¥•: ${error}`);
    }
  };

  // ÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´
  useEffect(() => {
    addDebugLog('ÂºÄÂßãÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´Ê®°Âùó');
    
    // Ê£ÄÊµãÈ∫¶ÂÖãÈ£éÊùÉÈôê
    checkMicrophoneAccess();
    
    // Ê£ÄÊµãÊµèËßàÂô®ÊîØÊåÅ
    const hasWebkitSpeech = 'webkitSpeechRecognition' in window;
    const hasSpeech = 'SpeechRecognition' in window;
    
    addDebugLog(`ÊµèËßàÂô®ÊîØÊåÅÊ£ÄÊµã: webkitSpeechRecognition=${hasWebkitSpeech}, SpeechRecognition=${hasSpeech}`);
    
    if (hasWebkitSpeech || hasSpeech) {
      try {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'zh-CN';
        
        addDebugLog('ËØ≠Èü≥ËØÜÂà´ÂØπË±°ÂàõÂª∫ÊàêÂäüÔºåÈÖçÁΩÆ: continuous=false, lang=zh-CN');
        
        recognition.onstart = () => {
          setIsListening(true);
          setSpeechError('');
          addDebugLog('ËØ≠Èü≥ËØÜÂà´ÂºÄÂßãÁõëÂê¨');
        };
        
        recognition.onresult = (event) => {
          let finalTranscript = '';
          let interimTranscript = '';
          
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += transcript;
            } else {
              interimTranscript += transcript;
            }
          }
          
          // Êõ¥Êñ∞ÊòæÁ§∫ÁöÑÊñáÊú¨ÔºàÂåÖÊã¨‰∏≠Èó¥ÁªìÊûúÔºâ
          const displayText = finalTranscript + interimTranscript;
          setLastRecognizedText(displayText);
          setCommandInput(displayText);
          
          // Âè™ÊúâÊúÄÁªàÁªìÊûúÊâçÂ§ÑÁêÜÂëΩ‰ª§
          if (finalTranscript) {
            const confidence = event.results[event.resultIndex][0].confidence;
            addDebugLog(`ÊúÄÁªàËØÜÂà´ÁªìÊûú: "${finalTranscript}" (ÁΩÆ‰ø°Â∫¶: ${confidence.toFixed(2)})`);
            processVoiceCommand(finalTranscript);
          } else if (interimTranscript) {
            addDebugLog(`‰∏≠Èó¥ËØÜÂà´ÁªìÊûú: "${interimTranscript}"`);
          }
        };
        
        recognition.onend = () => {
          // Âú®ÊåÅÁª≠ÁõëÂê¨Ê®°Âºè‰∏ãÔºåÂè™ÊúâÊâãÂä®ÂÅúÊ≠¢ÊâçËÆæÁΩÆ‰∏∫false
          if (!isListening) {
            addDebugLog('ËØ≠Èü≥ËØÜÂà´Â∑≤ÁªìÊùü');
          } else {
            addDebugLog('ËØ≠Èü≥ËØÜÂà´ÊÑèÂ§ñÁªìÊùüÔºåÂ∞ùËØïÈáçÊñ∞ÂêØÂä®');
            // Â¶ÇÊûúÊòØÊÑèÂ§ñÁªìÊùü‰∏î‰ªçÂú®ÁõëÂê¨Áä∂ÊÄÅÔºåÂ∞ùËØïÈáçÊñ∞ÂêØÂä®
            setTimeout(() => {
              if (isListening && speechRecognition) {
                try {
                  speechRecognition.start();
                  addDebugLog('ËØ≠Èü≥ËØÜÂà´Â∑≤ÈáçÊñ∞ÂêØÂä®');
                } catch (error) {
                  addDebugLog(`ÈáçÊñ∞ÂêØÂä®Â§±Ë¥•: ${error}`);
                  setIsListening(false);
                }
              }
            }, 100);
          }
        };
        
        recognition.onerror = (event) => {
          let errorMsg = `ËØ≠Èü≥ËØÜÂà´ÈîôËØØ: ${event.error}`;
          let suggestion = '';
          
          // ÈíàÂØπ‰∏çÂêåÈîôËØØÁ±ªÂûãÊèê‰æõÂÖ∑‰ΩìÂª∫ËÆÆ
          switch (event.error) {
            case 'no-speech':
              suggestion = 'Êú™Ê£ÄÊµãÂà∞ËØ≠Èü≥ËæìÂÖ•„ÄÇËØ∑Á°Æ‰øùÔºö1) È∫¶ÂÖãÈ£éÊùÉÈôêÂ∑≤ÊéàÊùÉ 2) È∫¶ÂÖãÈ£éÂ∑•‰ΩúÊ≠£Â∏∏ 3) ËØ¥ËØùÂ£∞Èü≥Ë∂≥Â§üÂ§ß 4) ÁéØÂ¢ÉÂô™Èü≥‰∏çË¶ÅÂ§™Â§ß';
              break;
            case 'audio-capture':
              suggestion = 'Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é„ÄÇËØ∑Ê£ÄÊü•È∫¶ÂÖãÈ£éÊùÉÈôêÂíåËÆæÂ§áËøûÊé•';
              break;
            case 'not-allowed':
              suggestion = 'È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù„ÄÇËØ∑Âú®ÊµèËßàÂô®ËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏È∫¶ÂÖãÈ£éËÆøÈóÆ';
              break;
            case 'network':
              suggestion = 'ÁΩëÁªúÈîôËØØ„ÄÇËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•';
              break;
            case 'service-not-allowed':
              suggestion = 'ËØ≠Èü≥ËØÜÂà´ÊúçÂä°‰∏çÂèØÁî®„ÄÇËØ∑Á®çÂêéÈáçËØï';
              break;
            default:
              suggestion = 'Êú™Áü•ÈîôËØØÔºåËØ∑ÈáçËØï';
          }
          
          errorMsg += ` | Âª∫ËÆÆ: ${suggestion}`;
          setSpeechError(errorMsg);
          
          // Êüê‰∫õÈîôËØØ‰∏çÈúÄË¶ÅÂÅúÊ≠¢ÁõëÂê¨Áä∂ÊÄÅÔºàÂ¶Çno-speechÔºâÔºåËÆ©Áî®Êà∑ÊâãÂä®ÊéßÂà∂
          if (event.error === 'not-allowed' || event.error === 'service-not-allowed' || event.error === 'audio-capture') {
            setIsListening(false);
          }
          
          addDebugLog(errorMsg);
          console.error('üé§ ËØ≠Èü≥ËØÜÂà´ÈîôËØØËØ¶ÊÉÖ:', event);
        };
        
        setSpeechRecognition(recognition);
        setSpeechSupported(true);
        addDebugLog('ËØ≠Èü≥ËØÜÂà´Ê®°ÂùóÂàùÂßãÂåñÂÆåÊàê');
      } catch (error) {
        const errorMsg = `ËØ≠Èü≥ËØÜÂà´ÂàùÂßãÂåñÂ§±Ë¥•: ${error}`;
        setSpeechError(errorMsg);
        addDebugLog(errorMsg);
        console.error('üé§ ËØ≠Èü≥ËØÜÂà´ÂàùÂßãÂåñÈîôËØØ:', error);
      }
    } else {
      const errorMsg = 'ÊµèËßàÂô®‰∏çÊîØÊåÅËØ≠Èü≥ËØÜÂà´ÂäüËÉΩ';
      setSpeechError(errorMsg);
      addDebugLog(errorMsg);
    }
  }, []);

  // Â§ÑÁêÜËØ≠Èü≥ÂëΩ‰ª§
  const processVoiceCommand = (command: string) => {
    const lowerCommand = command.toLowerCase();
    addDebugLog(`Â§ÑÁêÜËØ≠Èü≥ÂëΩ‰ª§: "${command}"`);
    
    if (lowerCommand.includes('Êñ∞Âª∫') || lowerCommand.includes('Ê∑ªÂä†') || lowerCommand.includes('ÂàõÂª∫')) {
      addDebugLog('ÊâßË°åÂëΩ‰ª§: Êñ∞Âª∫‰∫ã‰ª∂');
      handleAddEvent();
    } else if (lowerCommand.includes('Âà†Èô§') && selectedEvent) {
      addDebugLog('ÊâßË°åÂëΩ‰ª§: Âà†Èô§‰∫ã‰ª∂');
      handleDeleteEvent();
    } else if (lowerCommand.includes('ÁºñËæë') && selectedEvent) {
      addDebugLog('ÊâßË°åÂëΩ‰ª§: ÁºñËæë‰∫ã‰ª∂');
      handleEditToggle();
    } else if (lowerCommand.includes('‰øùÂ≠ò') && isEditing) {
      addDebugLog('ÊâßË°åÂëΩ‰ª§: ‰øùÂ≠òÁºñËæë');
      handleSaveEdit();
    } else {
      addDebugLog('Êú™ÂåπÈÖçÂà∞ÂëΩ‰ª§ÔºåÊñáÊú¨Â∑≤Â°´ÂÖ•ËæìÂÖ•Ê°Ü');
      // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÁöÑÂëΩ‰ª§ÔºåÂ∞ÜËØ≠Èü≥ÊñáÊú¨Â°´ÂÖ•ÂëΩ‰ª§ËæìÂÖ•Ê°Ü
      setCommandInput(command);
    }
  };

  // ÊãñÂä®Áõ∏ÂÖ≥ÂáΩÊï∞
  const handleMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true);
    setDragOffset({
      x: e.clientX - debugPanelPosition.x,
      y: e.clientY - debugPanelPosition.y
    });
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isDragging) {
      setDebugPanelPosition({
        x: e.clientX - dragOffset.x,
        y: e.clientY - dragOffset.y
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // Ê∑ªÂä†ÂÖ®Â±ÄÈº†Ê†á‰∫ã‰ª∂ÁõëÂê¨
  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, dragOffset]);

  // ÂàáÊç¢ËØ≠Èü≥ËØÜÂà´Áä∂ÊÄÅ
  const toggleVoiceRecognition = () => {
    if (!speechSupported) {
      addDebugLog('ËØ≠Èü≥ËØÜÂà´‰∏çÊîØÊåÅÔºåÊó†Ê≥ïÂêØÂä®');
      return;
    }
    
    if (!speechRecognition) {
      addDebugLog('ËØ≠Èü≥ËØÜÂà´ÂØπË±°Êú™ÂàùÂßãÂåñ');
      return;
    }
    
    if (isListening) {
      // ÂÅúÊ≠¢ËØ≠Èü≥ËØÜÂà´
      try {
        addDebugLog('ÂÅúÊ≠¢ËØ≠Èü≥ËØÜÂà´');
        setIsListening(false);
        speechRecognition.stop();
        setSpeechError('');
      } catch (error) {
        const errorMsg = `ÂÅúÊ≠¢ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•: ${error}`;
        setSpeechError(errorMsg);
        addDebugLog(errorMsg);
      }
    } else {
      // ÂºÄÂßãËØ≠Èü≥ËØÜÂà´
      try {
        addDebugLog('ÂêØÂä®ËØ≠Èü≥ËØÜÂà´');
        setLastRecognizedText('');
        setCommandInput('');
        setSpeechError('');
        speechRecognition.start();
      } catch (error) {
        const errorMsg = `ÂêØÂä®ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•: ${error}`;
        setSpeechError(errorMsg);
        addDebugLog(errorMsg);
      }
    }
  };

  const handleEventClick = (event: Event) => {
    setSelectedEvent(event);
    setIsEditing(false);
  };

  function calcEventColor(importance: number, urgency: number) {
    // importance, urgency ‚àà [0,1]
    // ËÆ°ÁÆóÊùÉÈáçÔºåË∂äÂ§ßË∂äÁ∫¢ÔºåË∂äÂ∞èË∂äËìù
    const weight = (importance + urgency) / 2;
    // hue: 220(Ëìù) ‚Üí 0(Á∫¢)
    const hue = 220 - 220 * weight;
    // È•±ÂíåÂ∫¶Âíå‰∫ÆÂ∫¶ÂèØÂæÆË∞É
    const saturation = 80;
    const lightness = 55 - 20 * weight; // Ë∂äÈáçË¶ÅË∂äÊöó
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  }

  const handleAddEvent = () => {
    const importance = 0.5;
    const urgency = 0.5;
    const color = calcEventColor(importance, urgency);
    const newEvent: Event = {
      id: `evt_${Date.now()}`,
      name: 'Êñ∞‰∫ã‰ª∂',
      size: 50,
      color,
      importance,
      urgency,
      startTime: new Date().toISOString(),
      endTime: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(),
      details: {}
    };

    eventManager.addEvent(newEvent);
    setEvents(eventManager.getAllEvents());
    setSelectedEvent(newEvent);
    setIsEditing(true);
    setTempEvent({ ...newEvent });
  };

  const handleEditToggle = () => {
    if (selectedEvent) {
      setIsEditing(!isEditing);
      setTempEvent({ ...selectedEvent });
    }
  };

  const handleSaveEdit = () => {
    if (selectedEvent && tempEvent) {
      eventManager.updateEvent(selectedEvent.id, tempEvent);
      const updatedEvents = eventManager.getAllEvents();
      setEvents(updatedEvents);
      
      const updatedEvent = eventManager.getEvent(selectedEvent.id);
      if (updatedEvent) {
        setSelectedEvent(updatedEvent);
      }
      setIsEditing(false);
    }
  };

  const handleDeleteEvent = () => {
    if (selectedEvent) {
      eventManager.deleteEvent(selectedEvent.id);
      const updatedEvents = eventManager.getAllEvents();
      setEvents(updatedEvents);
      setSelectedEvent(null);
      setIsEditing(false);
    }
  };

  const handleFieldChange = (field: keyof Event, value: any) => {
    if (tempEvent) {
      const updated = { ...tempEvent, [field]: value };
      // Â¶ÇÊûúÊîπÁöÑÊòØÈáçË¶ÅÊÄßÊàñÁ¥ßËø´ÊÄßÔºåËá™Âä®Êõ¥Êñ∞È¢úËâ≤
      if (field === 'importance' || field === 'urgency') {
        const importance = field === 'importance' ? value : updated.importance ?? 0.5;
        const urgency = field === 'urgency' ? value : updated.urgency ?? 0.5;
        updated.color = calcEventColor(importance, urgency);
      }
      setTempEvent(updated);
    }
  };

  const handleDetailChange = (field: keyof Event['details'], value: any) => {
    if (tempEvent) {
      setTempEvent({
        ...tempEvent,
        details: {
          ...(tempEvent.details ?? {}),
          [field]: value
        }
      });
    }
  };

  return (
    <div className="schedule-container">
      {/* ÁéØÂ¢ÉÊåáÁ§∫Âô® - ‰ªÖÂú®ÂºÄÂèëÁéØÂ¢ÉÊòæÁ§∫ */}
      {isDevelopment && (
        <div className="environment-indicator">
          <span className="env-badge">ÂºÄÂèëÁéØÂ¢É</span>
          <button 
            className="debug-toggle-btn"
            onClick={() => setDebugPanelVisible(!debugPanelVisible)}
            title={debugPanelVisible ? 'ÂÖ≥Èó≠Ë∞ÉËØïÈù¢Êùø' : 'ÊâìÂºÄË∞ÉËØïÈù¢Êùø'}
          >
            üîß
          </button>
        </div>
      )}
      
      {/* ËØ≠Èü≥Ë∞ÉËØïÈù¢Êùø - ‰ªÖÂú®ÂºÄÂèëÁéØÂ¢ÉÊòæÁ§∫ */}
      {isDevelopment && debugPanelVisible && (
        <div 
          className="speech-debug-panel"
          style={{
            left: `${debugPanelPosition.x}px`,
            top: `${debugPanelPosition.y}px`,
            cursor: isDragging ? 'grabbing' : 'default'
          }}
        >
          <div 
            className="debug-header"
            onMouseDown={handleMouseDown}
            style={{ cursor: 'grab' }}
          >
            üé§ ËØ≠Èü≥Ë∞ÉËØï‰ø°ÊÅØ
            <button 
              className="debug-close-btn"
              onClick={() => setDebugPanelVisible(false)}
              title="ÂÖ≥Èó≠Ë∞ÉËØïÈù¢Êùø"
            >
              ‚úï
            </button>
          </div>
          <div className="debug-status">
            <div className="status-item">
              <span className="status-label">ÊîØÊåÅÁä∂ÊÄÅ:</span>
              <span className={`status-value ${speechSupported ? 'success' : 'error'}`}>
                {speechSupported ? '‚úÖ ÊîØÊåÅ' : '‚ùå ‰∏çÊîØÊåÅ'}
              </span>
            </div>
            <div className="status-item">
              <span className="status-label">ÁõëÂê¨Áä∂ÊÄÅ:</span>
              <span className={`status-value ${isListening ? 'listening' : 'idle'}`}>
                {isListening ? 'üî¥ ÁõëÂê¨‰∏≠' : '‚ö™ Á©∫Èó≤'}
              </span>
            </div>
            <div className="status-item">
              <span className="status-label">È∫¶ÂÖãÈ£éÊùÉÈôê:</span>
              <span className={`status-value ${microphonePermission === 'granted' ? 'success' : microphonePermission === 'denied' ? 'error' : 'warning'}`}>
                {microphonePermission === 'granted' ? '‚úÖ Â∑≤ÊéàÊùÉ' : 
                 microphonePermission === 'denied' ? '‚ùå Ë¢´ÊãíÁªù' : '‚ö†Ô∏è Êú™Áü•'}
              </span>
            </div>
            <div className="status-item">
              <span className="status-label">Èü≥È¢ëÁ∫ßÂà´:</span>
              <span className="status-value">
                <span className="audio-level-bar">
                  <span 
                    className="audio-level-fill" 
                    style={{ width: `${Math.min(audioLevel * 2, 100)}%` }}
                  ></span>
                </span>
                <span className="audio-level-text">{audioLevel}</span>
              </span>
            </div>
            {speechError && (
              <div className="status-item">
                <span className="status-label">ÈîôËØØ‰ø°ÊÅØ:</span>
                <span className="status-value error">{speechError}</span>
              </div>
            )}
            {lastRecognizedText && (
              <div className="status-item">
                <span className="status-label">ÊúÄÂêéËØÜÂà´:</span>
                <span className="status-value">"{lastRecognizedText}"</span>
              </div>
            )}
          </div>
          <div className="debug-logs">
            <div className="logs-header">Ë∞ÉËØïÊó•Âøó:</div>
            <div className="logs-content">
              {debugInfo.map((log, index) => (
                <div key={index} className="log-item">{log}</div>
              ))}
              {debugInfo.length === 0 && (
                <div className="log-item empty">ÊöÇÊó†Êó•Âøó</div>
              )}
            </div>
          </div>
        </div>
      )}
      
      <div className="voice-area">
        <CustomButton 
          width="8vw" 
          onClick={toggleVoiceRecognition}
          style={{
            backgroundColor: isListening ? '#ff6b6b' : '#4CAF50',
            animation: isListening ? 'pulse 1s infinite' : undefined
          }}
        >
          üé§ {isListening ? 'ÂÅúÊ≠¢ÁõëÂê¨' : 'ÂºÄÂßãÁõëÂê¨'}
        </CustomButton>
        <span className="command">
          <label className="command-label">Êåá‰ª§</label>
          <input 
            type="text" 
            className="command-input" 
            placeholder="ËØ∑ËæìÂÖ•Êåá‰ª§Êàñ‰ΩøÁî®ËØ≠Èü≥ËæìÂÖ•" 
            value={commandInput}
            onChange={(e) => setCommandInput(e.target.value)}
          />
          <CustomButton width="5vw">ÊâßË°å</CustomButton>
        </span>
        {/* Êñ∞Âª∫Êó•Á®ãÊåâÈíÆ */}
        <CustomButton
          width="10vw"
          onClick={handleAddEvent}
        >
          ‚ûï Êñ∞Âª∫Êó•Á®ã
        </CustomButton>
      </div>

      <div className="content-area">
        <div className="quadrant-view">
          <div className="axis-y"></div>
          <div className="axis-x"></div>
          <div className="axis-label axis-label-y">ÈáçË¶ÅÁ®ãÂ∫¶</div>
          <div className="axis-label axis-label-x">Á¥ßÊÄ•Á®ãÂ∫¶</div>
          {/* Âõõ‰∏™Ë±°Èôê */}
          <div className="quadrants">
            {events
              .map(event => (
                <EventTile
                  key={event.id}
                  event={event}
                  onClick={() => handleEventClick(event)}
                />
              ))}
          </div>
        </div>
        {/* ‰æßËæπÊ†è - ‰∫ã‰ª∂ËØ¶ÊÉÖ */}
        <div className="sidebar">
          {selectedEvent ? (
            <div className="event-details">
              {/* ‰∫ã‰ª∂Ê†áÈ¢òÂíåÊìç‰ΩúÊåâÈíÆ */}
              <div className="detail-header">
                <h3>
                  {isEditing ? (
                    <input
                      type="text"
                      value={tempEvent?.name || ''}
                      onChange={(e) => handleFieldChange('name', e.target.value)}
                      className="edit-input"
                    />
                  ) : (
                    selectedEvent.name
                  )}
                </h3>

                <div className="action-buttons">
                  {isEditing ? (
                    <>
                      <button className="save-btn" onClick={handleSaveEdit}>‰øùÂ≠ò</button>
                      <button className="cancel-btn" onClick={() => setIsEditing(false)}>ÂèñÊ∂à</button>
                    </>
                  ) : (
                    <button className="edit-btn" onClick={handleEditToggle}>ÁºñËæë</button>
                  )}
                  <button className="delete-btn" onClick={handleDeleteEvent}>Âà†Èô§</button>
                </div>
              </div>
              {/* Êó∂Èó¥Â≠óÊÆµ */}
              <div className="detail-item">
                <span className="detail-label">Êó∂Èó¥</span>
                {isEditing ? (
                  <div className="edit-fields">
                    <input
                      type="datetime-local"
                      value={tempEvent?.startTime?.substring(0, 16) || ''}
                      onChange={(e) => handleFieldChange('startTime', e.target.value)}
                      className="edit-input"
                    />
                    <span>Ëá≥</span>
                    <input
                      type="datetime-local"
                      value={tempEvent?.endTime?.substring(0, 16) || ''}
                      onChange={(e) => handleFieldChange('endTime', e.target.value)}
                      className="edit-input"
                    />
                  </div>
                ) : (
                  <div className="detail-value">
                    {new Date(selectedEvent.startTime).toLocaleString()} -
                    {new Date(selectedEvent.endTime).toLocaleTimeString()}
                  </div>
                )}
              </div>

              {/* Á¥ßËø´ÊÄßÂ≠óÊÆµ */}
              <div className="detail-item">
                <span className="detail-label">Á¥ßËø´ÊÄß</span>
                <div className="detail-value">
                  {
                    isEditing ? (
                      <div className="edit-fields">
                        <input
                          type="range"
                          min="0"
                          max="1"
                          step="0.01"
                          value={tempEvent?.urgency || 0}
                          onChange={(e) => handleFieldChange('urgency', parseFloat(e.target.value))}
                          className="edit-slider"
                        />
                        <span>{tempEvent?.urgency?.toFixed(2)}</span>
                      </div>
                    ) : (
                      selectedEvent.urgency > 0.7 ? 'È´ò' : selectedEvent.urgency > 0.4 ? '‰∏≠' : '‰Ωé'
                    )}
                  </div>
              </div>

              {/* ÈáçË¶ÅÊÄßÂ≠óÊÆµ */}
              <div className="detail-item">
                <span className="detail-label">ÈáçË¶ÅÊÄß</span>
                {isEditing ? (
                  <div className="edit-fields">
                    <input
                      type="range"
                      min="0"
                      max="1"
                      step="0.01"
                      value={tempEvent?.importance || 0}
                      onChange={(e) => handleFieldChange('importance', parseFloat(e.target.value))}
                      className="edit-slider"
                    />
                    <span>{tempEvent?.importance?.toFixed(2)}</span>
                  </div>
                ) : (
                  <div className="detail-value">
                    {selectedEvent.importance > 0.7 ? 'È´ò' : selectedEvent.importance > 0.4 ? '‰∏≠' : '‰Ωé'}
                  </div>
                )}
              </div>

              {/* Ââ©‰ΩôÂ∑•‰ΩúÈáèÂ≠óÊÆµ */}
              <div className="detail-item">
                <span className="detail-label">Ââ©‰ΩôÂ∑•‰ΩúÈáè</span>
                {isEditing ? (
                  <div className="edit-fields">
                    <input
                      type="number"
                      value={tempEvent?.size || 0}
                      onChange={(e) => handleFieldChange('size', parseInt(e.target.value))}
                      className="edit-input"
                    />
                    <span>%</span>
                  </div>
                ) : (
                  <div className="detail-value">
                    {selectedEvent.size}%
                  </div>
                )}
              </div>

              {/* Âú∞ÁÇπÂ≠óÊÆµ */}
              {selectedEvent.details?.location && (
                <div className="detail-item">
                  <span className="detail-label">Âú∞ÁÇπ</span>
                  {isEditing ? (
                    <input
                      type="text"
                      value={tempEvent?.details?.location || ''}
                      onChange={(e) => handleDetailChange('location', e.target.value)}
                      className="edit-input"
                    />
                  ) : (
                    <div className="detail-value">
                      {selectedEvent.details.location}
                    </div>
                  )}
                </div>
              )}

              {/* È¢ÑËÆ°ËÄóÊó∂Â≠óÊÆµ */}
              {selectedEvent.details?.estimatedHours && (
                <div className="detail-item">
                  <span className="detail-label">È¢ÑËÆ°ËÄóÊó∂</span>
                  {isEditing ? (
                    <input
                      type="number"
                      value={tempEvent?.details?.estimatedHours || ''}
                      onChange={(e) => handleDetailChange('estimatedHours', parseInt(e.target.value))}
                      className="edit-input"
                    />
                  ) : (
                    <div className="detail-value">
                      {selectedEvent.details.estimatedHours} Â∞èÊó∂
                    </div>
                  )}
                </div>
              )}

              {/* Â§áÊ≥®Â≠óÊÆµ */}
              {selectedEvent.details?.notes && (
                <div className="detail-item">
                  <span className="detail-label">Â§áÊ≥®</span>
                  {isEditing ? (
                    <textarea
                      value={tempEvent?.details?.notes || ''}
                      onChange={(e) => handleDetailChange('notes', e.target.value)}
                      className="edit-textarea"
                    />
                  ) : (
                    <div className="detail-value">
                      {selectedEvent.details.notes}
                    </div>
                  )}
                </div>
              )}
            </div>
          ) : (
            <div className="event-details">
              <h3>‰∫ã‰ª∂ËØ¶ÊÉÖ</h3>
              <p>ËØ∑ÁÇπÂáªÊó•Á®ãÁ£ÅË¥¥Êü•ÁúãÊàñ‰øÆÊîπËØ¶ÁªÜ‰ø°ÊÅØ</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ScheduleArea;